---
title: 'svgR in a Markdown Doc'
author: 'author'
date: "2020-02-04"
output: html_document
---

  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(svgR)
```


# Steps to Implement *shinyInputControl*

### 1. Building your svg

```{r, results='asis', }
box %<c-% function(pos, i, headTxt, fill, valTxt, valTxt2=NULL ){
    g(
         rect(
               xy=pos$rectXY[,i],
               wh=pos$rectWH[,i],
               fill=fill,
               stroke='blue',
               stroke.width=3
             ), 
             text(headTxt,
                xy=pos$headXY[,i],
                stroke='blue' 
             ),
             text(valTxt,
                xy=pos$txt1XY[,i]
             ),
             if(!is.null(valTxt2)){
                text(valTxt2,
                xy=pos$txt2XY[,i]
             ) 
             } else {
                 NULL
             }
    )
}

dimInit<-function(rectH){
  sep<-5
  rectW<-250
  rectY<-cumsum(c(0,rectH)+sep)
  rectXY<-rbind(100,rectY)
  rectWH<-rbind(250,rectH)
  headXY<-c(10,20)+rectXY
  txt1XY<-c(30,20)+headXY
  txt2XY<-c(0,20)+txt1XY
  WH<-c(400,sum(rectH)+(1+length(rectH))*sep)
  list(
    rectXY=rectXY,
    rectWH=rectWH,
    headXY=headXY,
    txt1XY=txt1XY,
    txt2XY=txt2XY,
    WH=WH
  )
}

rectH<-c(90,50)
pos<-dimInit(rectH)
WH<-pos$WH

WH<-c(400,200)
svgR(wh=WH,text('STEP1',xy=c(20,20)),
    box(pos, 1, 'shinyInputControl_svg.R', '#BBFFBB','add to parms', 'edit svgR'),
    box(pos, 2, 'shinyInputControl_svg.R', '#FFCCAA','commit to test')

 
)
````

1. In file **shinyInputControl_svg.R** 
    - Add to Parameters section as needed
        - Parameters section contains variables:
            - WH (width height) 
            - ID for the contol id
            - CMDS (may supply more than one)
        - Add here anything you want to be adjustable
    - add to the svgR(){} what you want to see
2. commit to test image 
 

### 2. Initializing the Control

```{r, results='asis', }





rectH<-c(50,70,70,50)
pos<-dimInit(rectH)
WH<-pos$WH


svgR(wh=WH, text('STEP2',xy=c(20,20)),
    box(pos, 1, 'app.R', 'pink','edit intialValue'),
    box(pos, 2, 'shinyInputControl.R', 'lightyellow','edit shinyInputControl()'),
    box(pos, 3, 'shinyInputControl.js', 'lightblue','edit shinyInputControl()'),
    box(pos, 4, 'app.R', '#FFCCAA','run to test')
     
)
````

1. In file **app.R**
   - set **initialValue** as appropriate
   - edit *ui*  if needed
   - edit *server* if needed
2. In file **shinyInputControl.R**
    - in function *shinyInputControl()*
        -  if necessary 
            - preprocess the *value* argument 
            - edit params 
            - edit 'data-value'=value
2. In file **shinyInputControl.js**
    - in function **initialize**
        - extract values from el attributes using 'extract attribute' dnd
        - do any needed processing of values here 
            - if a value represents an object
                - convert into object using 'From String' dnd
            - set data-value using 'set element data' dnd
3. run **App.R** and use browser to verify data-value attached
    - in the browser panel (right hand side) 
        - locate the div with the id matching your control id 
        - verify that the data-value attribute appears and has the value you assigned



### 3. Adding mouse events

```{r, results='asis'}
rectH<-c(70,50)
pos<-dimInit(rectH)
WH<-pos$WH

svgR(wh=WH,text('STEP3',xy=c(20,20)),
    box(pos, 1, 'shinyInputControl_svg.R', '#BBFFBB','add mouse events'),
    box(pos, 2, 'app.R', '#FFCCAA','run to test')
)
````

- In file **shinyInputControl_svg.R** 
    - add *onclick=CMDS*  for interactivity
- run **App.R** and test for on an click message
- use browser to verify value was assigned 


### 4. Adding Mouseclick Handler

```{r, results='asis', }
rectH<-c(70,70,50)
pos<-dimInit(rectH)
WH<-pos$WH

svgR(wh=WH,text('STEP4',xy=c(20,20)),
    box(pos, 1, 'shinyInputControl.js', 'lightblue','add clicked:'),
    box(pos, 2, 'shinyInputControl.R', 'lightyellow','edit params$CMDS'),
    box(pos, 3, 'app.R', '#FFCCAA','run to test')
)
````

1. In **shinyInputControl.js**
    - add handler **clicked:** (assuming that you are using mouse click)
        - typically this will
            - getValue
            - do something
            - setValue
2. In **shinyInputControl.R**
    - edit **params\$CMDS** to use cmd in client. (clicked)
        - `sprintf('shinyInputControlBinding.clicked("%s", evt)',params$ID)`
3. run **App.R** and use browser to verify data-value is modified on click

### 5. Handling Return Values From Client

```{r, results='asis', }

rectH<-c(70,50)
pos<-dimInit(rectH)
WH<-pos$WH

svgR(wh=WH,text('STEP 5',xy=c(20,20)),
    box(pos, 1, 'shinyInputControl.R', 'lightyellow','registerInputHandler'),
    box(pos, 2, 'app.R', '#FFCCAA','run to test')
)
````

1. In file **shinyInputControl.R** 
    - in *registerInputHandler*
        - do any post processing of value and return value
2. test return value of input\$controlId in App.R

### 6. Implement  Update using a Braindead Approach

```{r, results='asis', }
rectH<-c(70,90,90,50)
pos<-dimInit(rectH)
WH<-pos$WH


svgR(wh=WH, text('STEP6',xy=c(20,20)),
    box(pos, 1, 'app.R', 'pink','edit observer for update'),
    box(pos, 2, 'shinyInputControl.R', 'lightyellow','recreate svgTree', 'create & send message'),
    box(pos, 3, 'shinyInputControl.js', 'lightblue','extract value and set element', 'extract and replace tree'),
    box(pos, 4, 'app.R', '#FFCCAA','run to test')
)
````


1. In **App.R** 
    - Edit *observeEvent(input\$updateButton* to call
       - *updateshinyInputControl* with the proper value
2. In file **shinyInputControl.R** (use dnd)
    1. Recreate svg Tree, edit params=list as necessary
        - params=list(ID=inputId, WH=wh, value=value) 
        - svgTree<-*shinyInputControlWrapper*(params=params)
        - node<-as.character(svgTree)
    2. Form message
          mssg<-list( value=value, node=node) 
    3. Send message to client
          - session\$sendInputMessage(inputId, mssg)
3. In file **shinyInputControl.js** in function *receivemessage*
    1. extract value(s) 
        - var value = data.value;
    2. Possibly convert to object: i.e. value=JSON.parse(value);
    3. set element with new data
        - this.setValue($(el), value);
    4. update svg rendering by replacing the entire svgTree under the $(el)
        - var node=data.node; 
        - \$(el).empty().append(node); //this replaces the svgTree
4. In **App.R** validate that *updateshinyInputControl* works:
        -  the appearance changes
        -  value changes

### 7. Updating the Appearance Upon Receiving Input 

```{r, results='asis', }
rectH<-c(70,50)
pos<-dimInit(rectH)
WH<-pos$WH

svgR(wh=WH,text('STEP 7',xy=c(20,20)),
    box(pos, 1, 'shinyInputControl.R', 'lightyellow','add to registerInputHandler', 'updateshinyInputControl(...)'),
    box(pos, 2, 'app.R', '#FFCCAA','run to test')
)

````



- In **shinyInputControl.R**
    - In *registerInputHandler* prior to returning value
        - add *updateshinyInputControl(...)* 
      


